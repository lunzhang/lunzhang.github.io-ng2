"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require('@angular/core');
var widget_1 = require('../widget/widget');
var widgetshadow_1 = require('../widgetshadow/widgetshadow');
var NgGrid = (function () {
    function NgGrid() {
        this.onDragStart = new core_1.EventEmitter();
        this.onDrag = new core_1.EventEmitter();
        this.onDragStop = new core_1.EventEmitter();
        this.onResizeStart = new core_1.EventEmitter();
        this.onResize = new core_1.EventEmitter();
        this.onResizeStop = new core_1.EventEmitter();
        this.gridStyle = {
            'position': 'relative',
            '-webkit-touch-callout': 'none',
            '-webkit-user-select': 'none',
            '-khtml-user-select': 'none',
            '-moz-user-select': 'none',
            '-ms-user-select': 'none',
            'user-select': 'none'
        };
        this.gridConfig = {
            'maxCol': 5,
            'maxRow': 5,
            'theme': 'light',
            'colWidth': 250,
            'rowHeight': 180,
            'marginLeft': 10,
            'marginTop': 10,
            'marginRight': 10,
            'marginBottom': 10,
            'minWidth': 1,
            'minHeight': 1,
            'maxWidth': -1,
            'maxHeight': -1
        };
        this.widgets = [];
        this.windowScroll = {
            x: 0,
            y: 0
        };
    }
    NgGrid.prototype.ngOnInit = function () {
        for (var config in this.customConfig) {
            this.gridConfig[config] = this.customConfig[config];
        }
    };
    NgGrid.prototype.onMouseDown = function (e) {
    };
    NgGrid.prototype.onMouseMove = function (e) {
        if (this.activeWidget) {
            if (this.activeWidget.isDrag) {
                this.onDrag.emit(this.activeWidget);
                var top_1 = parseInt(this.activeWidget.style.top);
                var left = parseInt(this.activeWidget.style.left);
                var dx = e.clientX - this.activeWidget.mousePoint.x;
                var dy = e.clientY - this.activeWidget.mousePoint.y;
                var gridPos = this._getPosition();
                if (this.ngWidgetShadow.position.row != gridPos.row || this.ngWidgetShadow.position.col != gridPos.col) {
                    this._checkCollision(gridPos, this.activeWidget.size, this.activeWidget.id);
                    this.ngWidgetShadow.setPosition(gridPos);
                    this._calcGridSize();
                }
                if (top_1 > 0 || dy > 0) {
                    this.activeWidget.style.top = top_1 + dy > 0 ? (top_1 + dy).toString() + 'px' : 0;
                    this.activeWidget.mousePoint.y = e.clientY;
                }
                if (left > 0 || dx > 0) {
                    this.activeWidget.style.left = left + dx > 0 ? (left + dx).toString() + 'px' : 0;
                    this.activeWidget.mousePoint.x = e.clientX;
                }
            }
            else if (this.activeWidget.isResize) {
                this.onResize.emit(this.activeWidget);
                var dx = e.clientX - this.activeWidget.mousePoint.x;
                var dy = e.clientY - this.activeWidget.mousePoint.y;
                var size = this._getSize();
                var height = parseInt(this.activeWidget.style.height);
                var width = parseInt(this.activeWidget.style.width);
                if (this.ngWidgetShadow.size.x != size.x || this.ngWidgetShadow.size.y != size.y) {
                    this._checkCollision(this.activeWidget.position, size, this.activeWidget.id);
                    this.ngWidgetShadow.setSize(size);
                    this._calcGridSize();
                }
                if (height + dy >= this.gridConfig.minHeight * this.gridConfig.rowHeight) {
                    if (this.gridConfig.maxHeight == -1 || height + dy <= this.gridConfig.maxHeight * this.gridConfig.rowHeight + this.gridConfig.marginTop) {
                        this.activeWidget.style.height = (height + dy).toString() + 'px';
                        this.activeWidget.mousePoint.y = e.clientY;
                    }
                    else {
                        this.activeWidget.style.height = (this.gridConfig.maxHeight * this.gridConfig.rowHeight + this.gridConfig.marginTop).toString() + 'px';
                    }
                }
                else {
                    this.activeWidget.style.height = (this.gridConfig.minHeight * this.gridConfig.rowHeight).toString() + 'px';
                }
                if (width + dx >= this.gridConfig.minWidth * this.gridConfig.colWidth) {
                    if (this.gridConfig.maxWidth == -1 || width + dx <= this.gridConfig.maxWidth * this.gridConfig.colWidth + this.gridConfig.marginLeft) {
                        this.activeWidget.style.width = (width + dx).toString() + 'px';
                        this.activeWidget.mousePoint.x = e.clientX;
                    }
                    else {
                        this.activeWidget.style.width = (this.gridConfig.maxWidth * this.gridConfig.colWidth + this.gridConfig.marginLeft).toString() + 'px';
                    }
                }
                else {
                    this.activeWidget.style.width = (this.gridConfig.minWidth * this.gridConfig.colWidth).toString() + 'px';
                }
            }
        }
    };
    NgGrid.prototype.onMouseUp = function (e) {
        if (this.activeWidget) {
            if (this.activeWidget.isDrag) {
                this.onDragStop.emit(this.activeWidget);
                this.activeWidget.setPosition(this.ngWidgetShadow.position);
                this._findWidgetById(this.activeWidget.id).position = this.ngWidgetShadow.position;
                this._calcGridSize();
            }
            else if (this.activeWidget.isResize) {
                this.onResizeStop.emit(this.activeWidget);
                this.activeWidget.setSize(this.ngWidgetShadow.size);
                this._findWidgetById(this.activeWidget.id).size = this.ngWidgetShadow.size;
                this._calcGridSize();
            }
            this.ngWidgetShadow.deactivate();
            this.activeWidget.reset();
            this.activeWidget = null;
        }
    };
    NgGrid.prototype.onScroll = function (e) {
        if (this.activeWidget) {
            if (this.activeWidget.isDrag) {
                var dx = window.scrollX - this.windowScroll.x;
                var dy = window.scrollY - this.windowScroll.y;
                var top_2 = parseInt(this.activeWidget.style.top);
                var left = parseInt(this.activeWidget.style.left);
                var gridPos = this._getPosition();
                if (this.ngWidgetShadow.position.row != gridPos.row || this.ngWidgetShadow.position.col != gridPos.col) {
                    this._checkCollision(gridPos, this.activeWidget.size, this.activeWidget.id);
                    this.ngWidgetShadow.setPosition(gridPos);
                    this._calcGridSize();
                }
                if (top_2 > 0 || dy > 0) {
                    this.activeWidget.style.top = top_2 + dy > 0 ? (this.activeWidget.style.top + dy).toString() + 'px' : 0;
                }
                if (left > 0 || dx > 0) {
                    this.activeWidget.style.left = left + dx > 0 ? (this.activeWidget.style.left + dx).toString() + 'px' : 0;
                }
            }
        }
        this.windowScroll.x = window.scrollX;
        this.windowScroll.y = window.scrollY;
    };
    NgGrid.prototype.onActivateWidget = function (widget) {
        if (widget.isDrag) {
            this.onDragStart.emit(widget);
        }
        else if (widget.isResize) {
            this.onResizeStart.emit(widget);
        }
        this.ngWidgetShadow.activate();
        this.ngWidgetShadow.setPosition(widget.position);
        this.ngWidgetShadow.setSize(widget.size);
        this.activeWidget = widget;
    };
    NgGrid.prototype.onClose = function (widget) {
        for (var i = 0; i < this.widgets.length; i++) {
            if (this.widgets[i].id == widget.id) {
                this.widgets.splice(i, 1);
            }
        }
    };
    NgGrid.prototype.addWidget = function () {
        function guid() {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
            }
            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
        }
        var emptyCol = this._findEmptyCol();
        var newWidget = {
            id: guid(),
            position: {
                'col': emptyCol,
                'row': 1
            },
            size: {
                'x': 1,
                'y': 1
            }
        };
        this.widgets.push(newWidget);
        this._calcGridSize();
        return newWidget;
    };
    NgGrid.prototype.empty = function () {
        this.widgets = [];
    };
    NgGrid.prototype._getPosition = function () {
        var col = Math.round(parseInt(this.activeWidget.style.left) / (this.gridConfig.colWidth + this.gridConfig.marginLeft / 2)) + 1;
        var row = Math.round(parseInt(this.activeWidget.style.top) / (this.gridConfig.rowHeight + this.gridConfig.marginTop / 2)) + 1;
        return { 'col': col, 'row': row };
    };
    NgGrid.prototype._getSize = function () {
        var x = Math.round(parseInt(this.activeWidget.style.width) / (this.gridConfig.colWidth + this.gridConfig.marginLeft / 2));
        var y = Math.round(parseInt(this.activeWidget.style.height) / (this.gridConfig.rowHeight + this.gridConfig.marginTop / 2));
        return { 'x': x, 'y': y };
    };
    NgGrid.prototype._getMousePosition = function (e) {
        var refPos = this.grid.nativeElement.getBoundingClientRect();
        var left = e.clientX - refPos.left;
        var top = e.clientY - refPos.top;
        return {
            left: left,
            top: top
        };
    };
    NgGrid.prototype._findNgWidgetById = function (id) {
        for (var i = 0; i < this.ngWidgets.length; i++) {
            if (this.ngWidgets[i].id == id) {
                return this.ngWidgets[i];
            }
        }
    };
    NgGrid.prototype._findWidgetById = function (id) {
        for (var i = 0; i < this.widgets.length; i++) {
            if (this.widgets[i].id == id) {
                return this.widgets[i];
            }
        }
    };
    NgGrid.prototype._findEmptyCol = function () {
        var col = 0;
        this.widgets.forEach(function (widget) {
            if (widget.position.col > col)
                col = widget.position.col;
        });
        return col + 1;
    };
    NgGrid.prototype._getCollision = function (position, size, id) {
        var _this = this;
        var collisions = [];
        this.ngWidgets.forEach(function (widget) {
            if (widget.id != id && widget.id != _this.activeWidget.id) {
                if (((widget.position.col >= position.col && widget.position.col < position.col + size.x)
                    || (widget.position.col + widget.size.x - 1 >= position.col && widget.position.col + widget.size.x - 1 < position.col + size.x)
                    || (position.col >= widget.position.col && position.col < widget.position.col + widget.size.x))
                    && ((widget.position.row >= position.row && widget.position.row < position.row + size.y)
                        || (widget.position.row + widget.size.y - 1 >= position.row && widget.position.row + widget.size.y - 1 < position.row + size.y)
                        || (position.row >= widget.position.row && position.row < widget.position.row + widget.size.y))) {
                    collisions.push(widget);
                }
            }
        });
        return collisions;
    };
    NgGrid.prototype._checkCollision = function (position, size, id) {
        var _this = this;
        var collisions = this._getCollision(position, size, id);
        collisions.forEach(function (widget) {
            widget.position.row = position.row + size.y;
            widget.calcPosition();
            _this._checkCollision(widget.position, widget.size, widget.id);
        });
    };
    NgGrid.prototype._calcGridSize = function () {
        var maxRow = this.gridConfig.maxRow;
        var maxCol = this.gridConfig.maxCol;
        this.widgets.forEach(function (widget) {
            if ((widget.position.col + widget.size.x - 1) > maxCol)
                maxCol = widget.position.col + widget.size.x - 1;
            if ((widget.position.row + widget.size.y - 1) > maxRow)
                maxRow = widget.position.row + widget.size.y - 1;
        });
        if ((this.ngWidgetShadow.position.col + this.ngWidgetShadow.size.x - 1) > maxCol)
            maxCol = this.ngWidgetShadow.position.col + this.ngWidgetShadow.size.x - 1;
        if ((this.ngWidgetShadow.position.row + this.ngWidgetShadow.size.y - 1) > maxRow)
            maxRow = this.ngWidgetShadow.position.row + this.ngWidgetShadow.size.y - 1;
        this.gridStyle.width = ((maxCol * (this.gridConfig.colWidth + 2)) + (maxCol * this.gridConfig.marginLeft)
            + this.gridConfig.marginRight).toString() + 'px';
        this.gridStyle.height = ((maxRow * (this.gridConfig.rowHeight + 2)) + (maxRow * this.gridConfig.marginTop)
            + this.gridConfig.marginBottom).toString() + 'px';
    };
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], NgGrid.prototype, "onDragStart", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], NgGrid.prototype, "onDrag", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], NgGrid.prototype, "onDragStop", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], NgGrid.prototype, "onResizeStart", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], NgGrid.prototype, "onResize", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', core_1.EventEmitter)
    ], NgGrid.prototype, "onResizeStop", void 0);
    __decorate([
        core_1.ViewChild('grid'), 
        __metadata('design:type', Object)
    ], NgGrid.prototype, "grid", void 0);
    __decorate([
        core_1.ViewChildren(widget_1.NgWidget), 
        __metadata('design:type', core_1.QueryList)
    ], NgGrid.prototype, "ngWidgets", void 0);
    __decorate([
        core_1.ViewChild(widgetshadow_1.NgWidgetShadow), 
        __metadata('design:type', Object)
    ], NgGrid.prototype, "ngWidgetShadow", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object)
    ], NgGrid.prototype, "customConfig", void 0);
    __decorate([
        core_1.HostListener('mousedown', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Object]), 
        __metadata('design:returntype', void 0)
    ], NgGrid.prototype, "onMouseDown", null);
    __decorate([
        core_1.HostListener('mousemove', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Object]), 
        __metadata('design:returntype', void 0)
    ], NgGrid.prototype, "onMouseMove", null);
    __decorate([
        core_1.HostListener('mouseup', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Object]), 
        __metadata('design:returntype', void 0)
    ], NgGrid.prototype, "onMouseUp", null);
    __decorate([
        core_1.HostListener('window:scroll', ['$event']), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Object]), 
        __metadata('design:returntype', void 0)
    ], NgGrid.prototype, "onScroll", null);
    NgGrid = __decorate([
        core_1.Component({selector: 'grid',
            template: "<div #grid [ngStyle]=\"gridStyle\" class=\"grid\" [ngClass]=\"gridConfig.theme\"> <widget-shadow [gridConfig]=\"gridConfig\" > </widget-shadow> <widget *ngFor=\"let widget of widgets\" (onActivateWidget)=\"onActivateWidget($event)\" (onClose)=\"onClose($event)\" [id]=\"widget.id\" [content]=\"widget.content\" [position]=\"widget.position\" [widgetTitle]=\"widget.widgetTitle\" [gridConfig]=\"gridConfig\" > </widget> </div> ",
            styles: [".grid,.grid>>>div{line-height:normal;font-size:14px;box-sizing:border-box}.grid.dark{background-color:#0c0d0d}.grid.light{background-color:#e9eaed}.grid.sky{background-color:#2C3E50}"]
        }), 
        __metadata('design:paramtypes', [])
    ], NgGrid);
    return NgGrid;
}());
exports.NgGrid = NgGrid;

//# sourceMappingURL=grid.js.map
